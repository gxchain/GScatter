<template>
    <section class="identities">

        <nav-actions :actions="[
            {event:'create', text:locale(langKeys.GENERIC_New)}
        ]" v-on:create="createIdentity"></nav-actions>

        <search v-on:changed="changed => bind(changed, 'searchText')"></search>

        <section v-if="!identities.length" class="nothing-here">

            <figure class="header">
                {{locale(langKeys.IDENTITIES_Header)}}
            </figure>
            <figure class="sub-header">
                {{locale(langKeys.IDENTITIES_Description)}}
                <br><br>
                <btn :text="locale(langKeys.BUTTON_CreateIdentity)" v-on:clicked="createIdentity" margined="true"></btn>
            </figure>

        </section>
        <section v-if="identities.length" class="p20 scroller with-search">
            <section v-for="identity in filterBySearch()" class="panel-box">

                <!-- Header -->
                <section class="panel">
                    <figure class="header big">{{identity.name}}</figure>
                </section>

                <!-- Account information -->
                <section class="panel" v-if="Object.keys(identity.accounts).length">
                    <figure class="header small reverse-margin">{{locale(langKeys.IDENTITY_AccountHeader)}}</figure>
                    <section class="items" v-for="network in Object.keys(identity.accounts)">
                        <section class="item">
                            <span v-if="!explorer(network)">{{networkToName(network)}}</span>
                            <span v-else><a class="link-expo" :href="explorer(network)" target="_blank">{{networkToName(network)}}</a></span>
                            <span>{{identity.accounts[network].formatted()}}</span>
                            <section class="items token-balances"
                                     v-if="loadingTokenBalances && loadingTokenBalances === identity.publicKey">
                                <section class="item">
                                    Loading token balances
                                </section>
                            </section>
                            <section class="items token-balances" v-else v-for="bals in balancesFor(identity)">
                                <section class="items" v-for="balance in bals">
                                    <section class="item">
                                        <span>{{balance[0]}}</span>
                                        <span>{{balance[1]}}</span>
                                    </section>
                                </section>
                            </section>
                        </section>
                    </section>
                </section>

                <!-- Personal Information -->
                <section class="panel" v-if="fullKeysOf(identity.personal).length">
                    <figure class="header small reverse-margin">{{locale(langKeys.IDENTITY_PersonalHeader)}}</figure>
                    <section class="items">
                        <section class="item" v-for="key in fullKeysOf(identity.personal)">
                            <span>{{key}}</span>
                            <span>{{identity.personal[key]}}</span>
                        </section>
                    </section>
                </section>

                <!-- Location Information -->
                <section class="panel" v-for="location in identity.locations">
                    <section v-if="fullKeysOf(location).length">
                        <figure class="header small reverse-margin">{{locale(langKeys.IDENTITY_LocationHeader)}}
                        </figure>
                        <section class="items">
                            <section class="item" v-for="key in fullKeysOf(location)">
                                <span>{{key}}</span>
                                <span v-if="key === 'country'">{{location[key].name}}</span>
                                <span v-else>{{location[key]}}</span>
                            </section>
                        </section>
                    </section>
                </section>

                <!-- Actions -->
                <section class="panel">
                    <section class="actions">
                        <figure v-on:click="goToIdentity(identity)" class="action tooltip"><i class="fa fa-pencil"></i><span class="tooltiptext" style="margin-left:10px;">edit</span></figure>
                        <section v-if="Object.keys(identity.accounts).length">
                            <figure class="action tooltip" @click="showingTokens = identity" v-if="!showingTokensFor(identity)">
                                <i class="fa fa-circle-thin"></i><span class="tooltiptext" style="margin-left:12px;">load</span></figure>
                            <figure class="action tooltip" @click="showingTokens = null" v-else><i
                                    class="fa fa-times-circle"></i><span class="tooltiptext" style="margin-left:12px;width:60px;">cancel</span></figure>
                        </section>
                        <figure class="action red right tooltip" v-on:click="removeIdentity(identity)"><i
                                class="fa fa-minus-square"></i><span class="tooltiptext" style="margin-left:-82px;width:60px;">remove</span></figure>
                    </section>
                </section>

            </section>
        </section>
    </section>
</template>

<script>
    import {mapActions, mapGetters, mapState} from 'vuex';
    import * as Actions from '../store/constants';
    import {RouteNames} from '../vue/Routing';
    import Network from '../models/Network';
    import AlertMsg from '../models/alerts/AlertMsg';
    import ObjectHelpers from '../util/ObjectHelpers';
    import PluginRepository from '../plugins/PluginRepository';

    export default {
        data() {
            return {
                searchText: '',
                balances: [],
                showingTokens: null,
                loadingTokenBalances: null,
            };
        },
        computed: {
            ...mapState([
                'scatter'
            ]),
            ...mapGetters([
                'identities',
            ])
        },
        methods: {
            bind(changed, original) {
                this[original] = changed;
            },
            fullKeysOf(obj) {
                return Object.keys(obj).filter(key => {
                    switch (typeof obj[key]) {
                        case 'string':
                            return obj[key].length;
                        case 'boolean':
                            return true;
                        default:
                            return obj[key][Object.keys(obj[key])[0]].length;
                    }
                });
            },
            showingTokensFor(identity) {
                return this.showingTokens && (identity.publicKey === this.showingTokens.publicKey);
            },
            async bindBalances(identity) {
                this.loadingTokenBalances = identity.publicKey;
                let netAccountMap = [];
                Object.keys(identity.accounts).map(netString =>
                    netAccountMap.push({account: identity.accounts[netString], netString}));

                netAccountMap = ObjectHelpers.distinct(netAccountMap);

                await Promise.all(netAccountMap.map(async netAccount => {
                    await this.accountBalances(netAccount, identity);
                }));

                this.loadingTokenBalances = null;
            },
            async accountBalances({account, netString}, identity) {
                let network = Network.fromUnique(netString);

                if (!network.host) {
                    const hostedNetwork = this.scatter.settings.networks.find(n => n.chainId === network.chainId && n.host !== '');
                    if (!hostedNetwork) return false;
                    network = hostedNetwork;
                }

                await PluginRepository.plugin(account.blockchain()).getBalances(account, network).then(balances => {
                    let idpkref = this.balances.find(bal => bal.idpk === identity.publicKey);
                    if (!idpkref) {
                        this.balances.push({idpk: identity.publicKey, balances: []});
                        idpkref = this.balances.find(bal => bal.idpk === identity.publicKey);
                    }

                    idpkref.balances.push({network: netString, balances});
                    return true;
                });
            },
            balancesFor(identity) {
                const identityBalances = this.balances.find(balances => balances.idpk === identity.publicKey);
                if (!identityBalances) return [];
                return identityBalances.balances.map(b => b.balances);
            },
            filterBySearch() {
                return this.identities.filter(x => JSON.stringify(x).indexOf(this.searchText) > -1);
            },
            removeIdentity(identity) {
                this[Actions.PUSH_ALERT](AlertMsg.RemovingIdentity(identity.name)).then(res => {
                    if (!res || !res.hasOwnProperty('accepted')) return false;
                    const scatter = this.scatter.clone();
                    scatter.keychain.identities = scatter.keychain.identities.filter(id => id.publicKey !== identity.publicKey);
                    scatter.keychain.permissions = scatter.keychain.permissions.filter(perm => perm.identity !== identity.publicKey);
                    this[Actions.UPDATE_STORED_SCATTER](scatter);
                });

            },
            goToIdentity(identity) {
                this.$router.push({name: RouteNames.IDENTITY, query: {publicKey: identity.publicKey}});
            },
            createIdentity() {
                this.$router.push({name: RouteNames.IDENTITY, query: {publicKey: 'create'}});
            },
            networkToName(_network) {
                const network = this.scatter.settings.networks.find(network => network.unique() === _network);
                if (!network) return 'Deleted Network';
                return network.hasOwnProperty('name') && network.name.length ? network.name : network.unique();
            },
            explorer(_network) {
                const network = this.scatter.settings.networks.find(network => network.unique() === _network);
                return network.explorer();
            },
            ...mapActions([
                Actions.UPDATE_STORED_SCATTER,
                Actions.PUSH_ALERT,
            ])
        },
        watch: {
            showingTokens() {
                this.balances = [];
                if (this.showingTokens)
                    this.bindBalances(this.showingTokens);
            }
        }
    };
</script>

<style lang="scss">

    .token-balances {
        display: inline-block;
        border-left: 10px solid rgba(0, 0, 0, 0.1);
        width: 100%;
        padding: 0 0 0 5px;

        .items {
            margin-top: 0 !important;
        }
    }

    .link-expo {
        color: #54a7fc;
    }

    .tooltip {
         position: relative;
    }

    .tooltip .tooltiptext {
        visibility: hidden;
        width: 40px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        position: absolute;
        z-index: 1;
    }
     
    .tooltip:hover .tooltiptext {
        visibility: visible;
    }

</style>
